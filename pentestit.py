"""
pentestit.py
-------
Тестовое задание Pentestit. Здесь и далее docstring в формате NumPy.
"""

import json
import logging
import typing
from argparse import ArgumentParser
from pathlib import Path

from test_result import test_result

logger = logging.getLogger(__name__)
logging.basicConfig(level=logging.INFO)


class JsonParser:
    """
    Класс реализует разбор JSON структуры и преобразует её в
    плоскую структуру типа List
    """

    def __init__(self) -> None:
        """
        Конструктор класса.

        Parameters
        ----------
            self.__source_data:
                Данные для разбора.
            self.__target_data:--
                Множество для хранения результата. Обеспечивает уникальность.
            self.__counter = 0
                Внутренний счетчик вызовов метода self.parse

        """
        self.__source_data = None
        self.__target_data = set()
        self.__counter = 0

    def load(self, file: str | Path) -> None:
        """
        Метод загружает словарь в self.__source_data.

        Parameters
        ----------
        file: Path | str
            путь к файлу, который следует загрузить.
        """
        if isinstance(file, str):
            file = Path(file)
        logger.info("Загрузка файла: %s", file.absolute())
        try:
            with open(file, "r", encoding="UTF-8") as fl:
                self.__source_data = json.load(fl)
        except Exception as e:
            logger.exception(
                exc_info=e, msg="непредвиденная ошибка чтения файла или разбора json"
            )
            raise
        else:
            self.__counter = 0
            self.__target_data = set()
            logger.info("файл загружен успешно: %s", file.absolute())
            logger.info("размер словаря для разбора: %s", len(self.__source_data))

    def save(self, file: str | Path):
        """
        Метод сохраняет множество из self.__target_data в файл.

        Parameters
        ----------
        file: Path | str
            путь к файлу, в который следует сохранить результат.
        """
        if isinstance(file, str):
            file = Path(file)
        try:
            with open(file, "w", encoding="utf-8") as fl:
                json.dump(list(self.__target_data), fl)
        except Exception as e:
            logger.exception(exc_info=e, msg="непредвиденная ошибка сохранения файла")
            raise
        else:
            logger.info("файл записан успешно: %s", file.absolute())

    @property
    def value(self) -> typing.List[typing.Any]:
        """
        Свойство возвращает список с уникальными значениями исходных данных
        
        Returns
        -------
        list: 
          Список с уникальными элементами или пустой список
        """
        if self.__target_data:
            return list(self.__target_data)
        return [] 

    def __call__(self, *args, **kwargs) -> None:
        """
        Метод вызывает разбор структуры без шума и пыли.
        """
        self.parse()

    def parse(self, value: typing.Any = None) -> None:
        """
        Метод рекурсивно разбирает структуру.

        Parameters
        ----------
        value: Any
            значение любого типа для анализа.
        """
        if self.__source_data is None:
            logger.error("нет входных данных")
            raise ValueError("Не стоит работать с пустыми данными")
        self.__counter += 1
        if self.__counter == 1:
            logger.info("разбор файла...")
            self.parse(self.__source_data)
        elif self._is_not_iterable(value):
            logger.info("простой тип: %s", type(value))
        elif self._is_str(value):
            logger.debug("значение - str: %s", type(value))
        elif self._is_dict(value):
            logger.debug("значение - dict: %s", type(value))
        elif self._is_iterable(value):
            logger.debug("значение - перечисляемый тип: %s", type(value))

    def _is_not_iterable(self, value: typing.Any) -> bool:
        """
        Метод проверяет, является ли значение итерируемым (но не строка)

        Parameters
        ----------
        value: Any
            значение любого типа для анализа.

        Returns
        -------
        bool:
            True если объект не итерируется иначе False
        """
        try:
            iter(value)
            return False
        except TypeError:
            logger.info("simple: %s", value)
            self.__target_data.add(value)
            return True

    def _is_str(self, value: typing.Any) -> bool:
        """
        Метод проверяет, является ли значение строкой.

        Parameters
        ----------
        value: Any
            значение любого типа для анализа.

        Returns
        -------
        bool:
            True если объект строка иначе False
        """
        if not isinstance(value, str):
            return False
        self.__target_data.add(value)
        return True

    def _is_dict(self, value: typing.Any) -> bool:
        """
        Метод проверяет, является ли значение словарём.

        Parameters
        ----------
        value: Any
            значение любого типа для анализа.

        Returns
        -------
        bool:
            True если объект словарь иначе False

        Notes
        -----
            Метод запускает рекурсивный разбор как ключа так и значения,
            потому, что оба значения м.б. итерируемыми
        """
        if not isinstance(value, dict):
            return False
        for key, value in value.items():
            self.parse(key)
            self.parse(value)
        return True

    def _is_iterable(self, value: typing.Any) -> bool:
        """
        Метод проверяет, является ли значение итерируемой сущностью.

        Parameters
        ----------
        value: Any
            значение любого типа для анализа.

        Returns
        -------
        bool:
            True если объект итерабелен иначе False

        Notes
        -----
            Метод запускает рекурсивный разбор значения.
        """
        try:
            iter(value)
        except TypeError:
            self.__target_data.add(value)
            return False
        else:
            for item in value:
                self.parse(item)
            return True

    def test(self) -> None:
        """
        Сравниваем эталонное значение с полученным.
        """
        assert set(test_result) == self.__target_data


def get_args() -> typing.Any:
    """
    Функция получает параметры запуска скрипта.

    Returns
    -------
    Any:
        Некие аргументы, тип которых долго выяснять, поэтому просто Any.
    """
    parser = ArgumentParser(prog="test_prog", description="Тестовое задание Pentestit")
    parser.add_argument("--source", required=True, help="файл для обработки.")
    parser.add_argument(
        "--target", required=True, help="файл для сохранения результата."
    )
    return parser.parse_args()


if __name__ == "__main__":
    args = get_args()
    if args.source and args.target and args.source == args.target:
        logger.error(
            "не стоит указывать одинаковые файлы на вход и выход: %s", args.source
        )
        exit(1)
    parser = JsonParser()
    parser.load(args.source)
    parser()
    parser.test()
    parser.save(args.target)
    logger.info(str(len(parser.value)))
    logger.info("result parse: %s", parser.value)
